# 程序员的自我修养

## 编译和链接

### 一般过程

```cpp
#include <stdio.h>

int main()
{
    printf("Hello World\n");
    return 0;
}
```

- 程序为什么要被编译器编译了之后才可以运行？
- 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？
- 最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的，怎么组织的？
- `#include <stdio.h>`是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它怎么实现的？
- 不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？
- Hello World程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？
- 如果没有操作系统，Hello World可以运行吗？如果要在一台没有操作系统的机器上运行Hello World需要什么？应该怎么实现？
- printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？
- Hello World程序在运行时，它在内存中是什么样子的？

![GCC编译过程分解](./Image/1)

1. 预编译：源代码文件(main.c)和相关头文件(stdio.h)预编译成一个.i文件
    - 命令行：`gcc -E main.c -o main.i`
    - 主要处理那些源代码文件中的以`#`开始的预编译指令(`#include`,`#define`等)
      - 删除所有的`#define`，并且展开所有的宏定义
      - 处理所有条件预编译指令`#if`、`#ifdef`、`#elif`、`#else`、`#endif`等
      - 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，也就是说被包含的文件可能还包含其他文件
      - 删除所有的注释`//`和`/**/`
      - 添加**行号**和**文件名标识**，比如`#2`(第二行)，`main.o`(文件名)，以便于编译时编译器产生**调试用的行号信息**以及编译时产生编译错误的**警告时能够显示行号**
      - 保留所有的的`#pragma`编译器指令，因为编译器需要使用使用到

经过预编译之后的`.i`文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到`.i`文件中。所以当无法判断宏定义是否正确或者头文件是否正确时，可以查看与编译后的文件来确定文件  

2. 编译：把预处理完的文件进行一系列的**词法分析**、**语法分析**、**语义分析**及**优化**后生产相应的汇编代码文件
    - 这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一
    - 命令行：`gcc -S main.i -o main.s`
    - 通过命令行可以得到汇编输出文件hello.s

3. 汇编：汇编器是将代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令
    - 汇编器的汇编或称相对于编译器来讲比较简单，没有复杂的语法也米有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表——翻译就可以了
    - 命令行：`as main.s -o hello.o`，调用汇编器as完成
    - 命令行：`gcc -c hello.c -o hello.o`，调用gcc直接从C源代码经过预编译、编译和汇编直接生成目标文件(Object File)

4. 链接：为什么需要链接？为什么汇编器不能直接输出可执行文件而是输出目标文件？

### 编译器做了什么

![编译过程](./Image/2)

编译过程分成六步：**扫描**->**语法分析**->**语义分析**->**源代码优化**->**目标代码生成**->**代码优化**

```cpp
array[index] = (index + 4) * (2 + 6)
```

1. 词法分析

源代码程序被输入到扫描器(Scanner)，进行简单的词法分析，运用一种类似有限状态机(Finite State Machine)的算法可以轻松地将源代码分割成一系列的记号(Token)  

比如上述代码存在28个非空字符，经过扫描后生成16个记号

| 记号 | 类型 |
| --- | --- |
| array | 标识符 |
| [ | 左方括号 |
| index | 标识符 |
| ] | 右方括号 |
| = | 赋值 |
| ( | 左原名括号 |
| index | 标识符 |
| + | 加号 |
| 4 | 数字 |
| ) | 右圆括号 |
| * | 乘号 |
| ( | 左圆括号 |
| 2 | 数字 |
| + | 加号 |
| 6 | 数字 |
| ) | 右圆括号 |

- 词法分析一般可以分为如下几类
  - 关键字
  - 标识符
  - 字面量（数字、字符串等）
  - 特使符号（加号、等号等）

在识别记号的同时，扫描器也完成了其他工作。比如将标识符存在**符号表**，将数字、字符串常量存放到**文字表**等，以备后面的步骤使用  

> 有一个叫做lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号

tip. 对于一些有预处理的语言（C语言等），它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器

------


2. 语法分析

语法分析器(Grammar Parser)将对由扫描器产生的记号进行语法分析，从而产生语法树(Syntax Tree)  
整个过程采用了上下文无关语法(Context-tree Grammar)的分析手段：由词法分析器生成的语法树就是以表达式(Expression)为节点的书

![上述代码语法树](./Image/3)

> 上述代码语法树

- 数字和符号是最小的表达式，他们不是由其他的表达式来组成的，所以他们通常作为整个语法树的叶节点
- 确定大部分运算符号的优先级和含义
  - 部分符号具有多重含义：比如`*`可以表示乘法，也可以表示取指针的值

语法分析阶段必须对上述内容进行区分，如果出现了表达式不合法：比如括号比匹配、表达式缺少操作符等，编译器就会报告语法分析阶段的错误  

> 语法分析也有一个现成的工具叫做yacc（Yet Another Compiler Compiler）可以根据用户给定的语法规则对输入的记号序列进行解析，从而构建出一棵语法树  
> 对于不同的编程语言，编译器的开发者只须改变语法规则，而无须为每个编译器编写一个语法分析器，所以它又被称为"编译器编译器(Compiler Compiler)"

3. 语义分析

语义分析交给语义分析器来完成  

语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解整个语句是否真正有意义（比如指针相乘是没有意义的大那是可以过语法分析）

编译器能分析的语义是静态语义

- 静态语义：编译器可以确定的语义
  - 通常包括声明的和类型的匹配，类型的转换
- 动态语义：运行期才能确定的语义
  - 运行期出现的语义相关的问题，比如除0错误

![语法树](./Image/4)

图中每个表达式（包括符号和数字）都被表示了类型，语义分析还对符号表里的符号类型也做了更新

-----

4. 中间语言生成

现代编译器有很多层次的优化，往往在源代码级别会有一个优化过程，就是源码级优化器(Source Code Optimizer)，在不同的编译器中可能会有不同的定义或者一些其他的差异

源码级优化器会在源代码级别上进行优化，比如上述代码`(2 + 6)`可以直接确定为`8`

当然还有一些其他复杂的优化

![优化后的语法树](./Image/5)

直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码(Intermediate Code)，他是语法树的顺序表示，其实他已经非常接近目标代码。但是它一般跟目标机器和运行时环境是无关的，比如它不包括数据的尺寸、变量地址、寄存器名称等  

中间代码有很多类型，不同的编译器中有着不同的形式，比较常见的有：**三地址码**(Three-address Code)和**P-代码**(P-Code)

```cpp
t1 = 2 + 6
t2 = index + 4
t3 = t1 * t2
array[index] = t3
```

上述式子是将`array[index] = (index + 4) * (2 + 6)`转换成三地址码的形式，利用t1、t2、t3这几个临时变量，并在此基础上进行优化，直接得出`t1 = 8`进行将t1替换成8，省去一个临时变量

```cpp
t1 = index + 4
t2 = t1 * 8
array[index] = t2
```

中间代码是的编译器可以被分为前端和后端。编译器**前端负责产生机器无关的中间代码**，编译器**后端将中间代码转换成目标机器代码**。这样对于一些可以跨平台的编译器而言，他们可以针对不同的平台使用同一个前端和针对不同的机器平台的数个后端

-----

5. 目标代码的生成与优化

源代码级优化器产生中间代码标志着下面的过程都属于编辑器后端。编译器后端主要包括**代码生成器(Code Generator)**和**目标代码优化器(Target Code Optimizer)**

- 代码生成器：将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等

```
movl index, %ecx        ; value of index to ecx
addl $4, %ecx           ; ecx = ecx + 4
mull $8, %ecx             ; ecx = ecx * 8
movl index, %eax        ; value of index to eax
movl %ecx, array(,eax,4)  ; array[index] = ecx
```

- 目标代码优化器：对上述的目标代码进行优化，比如：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等
  - 针对上述代码，乘法由一条相对复杂的基址比例变址寻址(Base Index Scale Addressing)的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式和lea是一样的

```
movl  index, %edx
leal  32(,%edx,8), %eax
movl  %eax, array(,%edx,4)
```

如果`index`和`array`定义在跟上面的源代码同一个编译单元里面，那么编译器可以为index和array分配空间，确定他们的地址。但是如果定义在**其他模块**怎么处理？

定义在**其他模块的全局变量和函数**在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件

### 模块拼接——静态链接

把每个源代码模块独立地编译，然后按照需要将它们**组装**起来，这个组装模块的过程就是**链接**

链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。因为现代的高级语言的诸多特性和功能，使得编译器、链接器更加复杂，功能更为强大，但是就本质而言其无非就是**把一些指令对其他符号地址的引用加以修正**

链接的过程主要包括了**地址和空间分配(Address and Storage Allocation)**、**符号决议(Symbol Resolution)**和**重定位(Relocation)**等步骤

